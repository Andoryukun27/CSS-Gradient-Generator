/**
 * Export System - Handles CSS export, file downloads, and clipboard operations
 */

export class ExportSystem {
    constructor() {
        this.supportedFormats = ['css', 'scss', 'less', 'stylus', 'json'];
        this.clipboardSupported = this.checkClipboardSupport();
    }

    /**
     * Initialize export system
     */
    init() {
        console.log('ðŸ“¤ Initializing Export System...');
        this.setupClipboardFallback();
    }

    /**
     * Check clipboard support
     */
    checkClipboardSupport() {
        return !!(navigator.clipboard && navigator.clipboard.writeText);
    }

    /**
     * Copy text to clipboard
     */
    async copyToClipboard(text) {
        try {
            if (this.clipboardSupported) {
                await navigator.clipboard.writeText(text);
                return true;
            } else {
                return this.fallbackCopyToClipboard(text);
            }
        } catch (error) {
            console.error('Failed to copy to clipboard:', error);
            return this.fallbackCopyToClipboard(text);
        }
    }

    /**
     * Fallback clipboard copy method
     */
    fallbackCopyToClipboard(text) {
        try {
            // Create temporary textarea
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-999999px';
            textarea.style.top = '-999999px';
            document.body.appendChild(textarea);
            
            // Select and copy
            textarea.focus();
            textarea.select();
            const successful = document.execCommand('copy');
            
            // Clean up
            document.body.removeChild(textarea);
            
            return successful;
        } catch (error) {
            console.error('Fallback copy failed:', error);
            return false;
        }
    }

    /**
     * Setup clipboard fallback for older browsers
     */
    setupClipboardFallback() {
        if (!this.clipboardSupported) {
            console.warn('Clipboard API not supported, using fallback method');
        }
    }

    /**
     * Download file
     */
    downloadFile(content, filename, mimeType = 'text/plain') {
        try {
            // Create blob
            const blob = new Blob([content], { type: mimeType });
            
            // Create download link
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            
            // Clean up
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            return true;
        } catch (error) {
            console.error('Failed to download file:', error);
            return false;
        }
    }

    /**
     * Generate CSS content
     */
    generateCSS(gradient, options = {}) {
        const {
            selector = '.gradient',
            property = 'background',
            includeVendorPrefixes = true,
            includeComments = true,
            minify = false
        } = options;

        let css = '';
        const gradientCSS = this.buildGradientCSS(gradient);

        if (includeComments && !minify) {
            css += `/* Generated by CSS Gradient Generator */\n`;
            css += `/* ${new Date().toISOString()} */\n\n`;
        }

        const spacing = minify ? '' : '  ';
        const lineBreak = minify ? '' : '\n';

        css += `${selector} {${lineBreak}`;

        if (includeVendorPrefixes) {
            // Add vendor prefixes for better compatibility
            const prefixes = ['-webkit-', '-moz-', '-o-', ''];
            prefixes.forEach(prefix => {
                css += `${spacing}${property}: ${prefix}${gradientCSS};${lineBreak}`;
            });
        } else {
            css += `${spacing}${property}: ${gradientCSS};${lineBreak}`;
        }

        css += `}${lineBreak}`;

        return css;
    }

    /**
     * Generate SCSS content
     */
    generateSCSS(gradient, options = {}) {
        const {
            variableName = 'gradient',
            includeComments = true,
            includeMixin = true
        } = options;

        let scss = '';
        const gradientCSS = this.buildGradientCSS(gradient);

        if (includeComments) {
            scss += `// Generated by CSS Gradient Generator\n`;
            scss += `// ${new Date().toISOString()}\n\n`;
        }

        // Variable
        scss += `$${variableName}: ${gradientCSS};\n\n`;

        // Mixin
        if (includeMixin) {
            scss += `@mixin ${variableName}-bg {\n`;
            scss += `  background: $${variableName};\n`;
            scss += `}\n\n`;

            // Usage example
            scss += `// Usage:\n`;
            scss += `// .my-element {\n`;
            scss += `//   @include ${variableName}-bg;\n`;
            scss += `// }\n`;
        }

        return scss;
    }

    /**
     * Generate Less content
     */
    generateLess(gradient, options = {}) {
        const {
            variableName = 'gradient',
            includeComments = true,
            includeMixin = true
        } = options;

        let less = '';
        const gradientCSS = this.buildGradientCSS(gradient);

        if (includeComments) {
            less += `// Generated by CSS Gradient Generator\n`;
            less += `// ${new Date().toISOString()}\n\n`;
        }

        // Variable
        less += `@${variableName}: ${gradientCSS};\n\n`;

        // Mixin
        if (includeMixin) {
            less += `.${variableName}-bg() {\n`;
            less += `  background: @${variableName};\n`;
            less += `}\n\n`;

            // Usage example
            less += `// Usage:\n`;
            less += `// .my-element {\n`;
            less += `//   .${variableName}-bg();\n`;
            less += `// }\n`;
        }

        return less;
    }

    /**
     * Generate Stylus content
     */
    generateStylus(gradient, options = {}) {
        const {
            variableName = 'gradient',
            includeComments = true,
            includeMixin = true
        } = options;

        let stylus = '';
        const gradientCSS = this.buildGradientCSS(gradient);

        if (includeComments) {
            stylus += `// Generated by CSS Gradient Generator\n`;
            stylus += `// ${new Date().toISOString()}\n\n`;
        }

        // Variable
        stylus += `${variableName} = ${gradientCSS}\n\n`;

        // Mixin
        if (includeMixin) {
            stylus += `${variableName}-bg()\n`;
            stylus += `  background ${variableName}\n\n`;

            // Usage example
            stylus += `// Usage:\n`;
            stylus += `// .my-element\n`;
            stylus += `//   ${variableName}-bg()\n`;
        }

        return stylus;
    }

    /**
     * Generate JSON export
     */
    generateJSON(gradient, options = {}) {
        const {
            includeMetadata = true,
            pretty = true
        } = options;

        const data = {
            gradient: gradient,
            css: this.buildGradientCSS(gradient)
        };

        if (includeMetadata) {
            data.metadata = {
                generator: 'CSS Gradient Generator',
                version: '1.0.0',
                timestamp: new Date().toISOString(),
                format: 'json'
            };
        }

        return JSON.stringify(data, null, pretty ? 2 : 0);
    }

    /**
     * Build gradient CSS string
     */
    buildGradientCSS(gradient) {
        const { type, angle, position, size, colorStops, repeating } = gradient;
        const prefix = repeating ? 'repeating-' : '';
        
        // Sort color stops by position
        const sortedStops = [...colorStops].sort((a, b) => a.position - b.position);
        const stops = sortedStops.map(stop => {
            const color = this.applyOpacity(stop.color, stop.opacity);
            return `${color} ${stop.position}%`;
        }).join(', ');

        switch (type) {
            case 'linear':
                const direction = this.angleToDirection(angle);
                return `${prefix}linear-gradient(${direction}, ${stops})`;
                
            case 'radial':
                const positionStr = `${position.x}% ${position.y}%`;
                return `${prefix}radial-gradient(${size} at ${positionStr}, ${stops})`;
                
            case 'conic':
                const conicPosition = `${position.x}% ${position.y}%`;
                return `${prefix}conic-gradient(from ${angle || 0}deg at ${conicPosition}, ${stops})`;
                
            default:
                return `linear-gradient(90deg, ${stops})`;
        }
    }

    /**
     * Apply opacity to color
     */
    applyOpacity(color, opacity = 1) {
        if (opacity === 1) return color;

        // Convert hex to rgba if needed
        if (color.startsWith('#')) {
            const rgb = this.hexToRgb(color);
            if (rgb) {
                return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
            }
        }

        // Handle existing rgba/hsla
        if (color.includes('rgba') || color.includes('hsla')) {
            return color.replace(/,\s*[\d.]+\)$/, `, ${opacity})`);
        }

        // Convert rgb/hsl to rgba/hsla
        if (color.startsWith('rgb(')) {
            return color.replace('rgb(', 'rgba(').replace(')', `, ${opacity})`);
        }
        
        if (color.startsWith('hsl(')) {
            return color.replace('hsl(', 'hsla(').replace(')', `, ${opacity})`);
        }

        return color;
    }

    /**
     * Convert hex to RGB
     */
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    /**
     * Convert angle to CSS direction
     */
    angleToDirection(angle) {
        const normalizedAngle = ((angle % 360) + 360) % 360;
        
        // Common directions
        const directions = {
            0: 'to top',
            45: 'to top right',
            90: 'to right',
            135: 'to bottom right',
            180: 'to bottom',
            225: 'to bottom left',
            270: 'to left',
            315: 'to top left'
        };

        return directions[normalizedAngle] || `${normalizedAngle}deg`;
    }

    /**
     * Export gradient in specified format
     */
    exportGradient(gradient, format, options = {}) {
        switch (format.toLowerCase()) {
            case 'css':
                return this.generateCSS(gradient, options);
            case 'scss':
                return this.generateSCSS(gradient, options);
            case 'less':
                return this.generateLess(gradient, options);
            case 'stylus':
                return this.generateStylus(gradient, options);
            case 'json':
                return this.generateJSON(gradient, options);
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
    }

    /**
     * Get file extension for format
     */
    getFileExtension(format) {
        const extensions = {
            css: 'css',
            scss: 'scss',
            less: 'less',
            stylus: 'styl',
            json: 'json'
        };
        
        return extensions[format.toLowerCase()] || 'txt';
    }

    /**
     * Get MIME type for format
     */
    getMimeType(format) {
        const mimeTypes = {
            css: 'text/css',
            scss: 'text/scss',
            less: 'text/less',
            stylus: 'text/stylus',
            json: 'application/json'
        };
        
        return mimeTypes[format.toLowerCase()] || 'text/plain';
    }

    /**
     * Generate filename
     */
    generateFilename(gradient, format, customName = null) {
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
        const extension = this.getFileExtension(format);
        
        if (customName) {
            return `${customName}.${extension}`;
        }
        
        const gradientType = gradient.type || 'gradient';
        return `${gradientType}-gradient-${timestamp}.${extension}`;
    }

    /**
     * Export and download
     */
    async exportAndDownload(gradient, format, options = {}) {
        try {
            const content = this.exportGradient(gradient, format, options);
            const filename = this.generateFilename(gradient, format, options.filename);
            const mimeType = this.getMimeType(format);
            
            const success = this.downloadFile(content, filename, mimeType);
            
            if (success) {
                console.log(`Successfully exported ${format.toUpperCase()} file: ${filename}`);
                return { success: true, filename, content };
            } else {
                throw new Error('Download failed');
            }
        } catch (error) {
            console.error('Export and download failed:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Export and copy to clipboard
     */
    async exportAndCopy(gradient, format, options = {}) {
        try {
            const content = this.exportGradient(gradient, format, options);
            const success = await this.copyToClipboard(content);
            
            if (success) {
                console.log(`Successfully copied ${format.toUpperCase()} to clipboard`);
                return { success: true, content };
            } else {
                throw new Error('Copy to clipboard failed');
            }
        } catch (error) {
            console.error('Export and copy failed:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Generate complete stylesheet
     */
    generateStylesheet(gradients, options = {}) {
        const {
            format = 'css',
            includeReset = false,
            includeUtilities = true,
            includeComments = true
        } = options;

        let stylesheet = '';

        if (includeComments) {
            stylesheet += `/* CSS Gradient Generator Stylesheet */\n`;
            stylesheet += `/* Generated: ${new Date().toISOString()} */\n\n`;
        }

        if (includeReset) {
            stylesheet += this.getCSSReset() + '\n\n';
        }

        // Add gradients
        gradients.forEach((gradient, index) => {
            const className = gradient.name || `gradient-${index + 1}`;
            const selector = `.${className.toLowerCase().replace(/\s+/g, '-')}`;
            
            stylesheet += this.generateCSS(gradient, {
                selector,
                includeComments: false,
                minify: false
            }) + '\n';
        });

        if (includeUtilities) {
            stylesheet += this.getUtilityClasses() + '\n';
        }

        return stylesheet;
    }

    /**
     * Get CSS reset
     */
    getCSSReset() {
        return `/* Basic CSS Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  line-height: 1.6;
}`;
    }

    /**
     * Get utility classes
     */
    getUtilityClasses() {
        return `/* Utility Classes */
.gradient-text {
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  color: transparent;
}

.gradient-border {
  border: 2px solid;
  border-image-slice: 1;
}

.gradient-overlay::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  opacity: 0.8;
  pointer-events: none;
}`;
    }

    /**
     * Validate export options
     */
    validateExportOptions(format, options) {
        if (!this.supportedFormats.includes(format.toLowerCase())) {
            throw new Error(`Unsupported format: ${format}`);
        }

        // Format-specific validation
        switch (format.toLowerCase()) {
            case 'css':
                if (options.selector && typeof options.selector !== 'string') {
                    throw new Error('CSS selector must be a string');
                }
                break;
            case 'scss':
            case 'less':
            case 'stylus':
                if (options.variableName && !/^[a-zA-Z_][a-zA-Z0-9_-]*$/.test(options.variableName)) {
                    throw new Error('Invalid variable name');
                }
                break;
        }

        return true;
    }

    /**
     * Get export statistics
     */
    getExportStats(gradient, format) {
        const content = this.exportGradient(gradient, format);
        
        return {
            format,
            size: new Blob([content]).size,
            lines: content.split('\n').length,
            characters: content.length,
            colorStops: gradient.colorStops.length,
            hasTransparency: gradient.colorStops.some(stop => stop.opacity < 1),
            isRepeating: gradient.repeating || false
        };
    }
}